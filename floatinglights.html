<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bokeh Lights with Gradient, Twinkle, Pulse, Float, and Depth Blur</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script>
    const scene = new THREE.Scene();

    // Gradient background
    const gradientCanvas = document.createElement("canvas");
    gradientCanvas.width = 256;
    gradientCanvas.height = 256;
    const ctx = gradientCanvas.getContext("2d");
    const gradient = ctx.createLinearGradient(0, 0, gradientCanvas.width, gradientCanvas.height);
    gradient.addColorStop(0, "#2b2e91");
    gradient.addColorStop(0.5, "#8e44ad");
    gradient.addColorStop(1, "#16a085");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, gradientCanvas.width, gradientCanvas.height);
    const texture = new THREE.CanvasTexture(gradientCanvas);
    scene.background = texture;

    const camera = new THREE.PerspectiveCamera(
      75, window.innerWidth / window.innerHeight, 0.1, 1000
    );
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const particles = [];
    const particleCount = 40;
    const colors = [0x00ffff, 0x00ccff, 0x9999ff, 0xff66cc, 0xffffff];

    // Bokeh circle texture
    const bokehCanvas = document.createElement("canvas");
    bokehCanvas.width = 64;
    bokehCanvas.height = 64;
    const bctx = bokehCanvas.getContext("2d");
    const radgrad = bctx.createRadialGradient(32, 32, 5, 32, 32, 32);
    radgrad.addColorStop(0, "rgba(255,255,255,1)");
    radgrad.addColorStop(0.5, "rgba(255,255,255,0.5)");
    radgrad.addColorStop(1, "rgba(255,255,255,0)");
    bctx.fillStyle = radgrad;
    bctx.fillRect(0, 0, 64, 64);
    const bokehTexture = new THREE.CanvasTexture(bokehCanvas);

    for (let i = 0; i < particleCount; i++) {
      const material = new THREE.SpriteMaterial({
        map: bokehTexture,
        color: colors[Math.floor(Math.random() * colors.length)],
        transparent: true,
        opacity: 0.8,
        depthWrite: false
      });
      const sprite = new THREE.Sprite(material);
      const baseSize = Math.random() * 2 + 1;
      sprite.scale.setScalar(baseSize);
      const z = Math.random() * -30; // spread deeper into scene
      sprite.position.set(
        Math.random() * 20 - 10,
        Math.random() * 10 - 5,
        z
      );
      sprite.userData = {
        baseSize: baseSize,
        twinkleSpeed: 0.01 + Math.random() * 0.02,
        twinklePhase: Math.random() * Math.PI * 2,
        floatSpeed: 0.5 + Math.random() * 1.5,
        floatPhase: Math.random() * Math.PI * 2,
        baseY: sprite.position.y,
        depth: z
      };
      scene.add(sprite);
      particles.push(sprite);
    }

    camera.position.z = 10;

    function animate() {
      requestAnimationFrame(animate);
      const time = performance.now() * 0.001;
      particles.forEach(p => {
        // move left to right
        p.position.x += 0.01;
        if (p.position.x > 12) {
          p.position.x = -12;
          p.userData.baseY = Math.random() * 10 - 5;
          p.userData.depth = Math.random() * -30;
          p.position.z = p.userData.depth;
        }
        // floating up and down
        p.position.y = p.userData.baseY + Math.sin(time * p.userData.floatSpeed + p.userData.floatPhase) * 0.5;
        // twinkle opacity
        const twinkle = Math.sin(time * p.userData.twinkleSpeed + p.userData.twinklePhase);
        let baseOpacity = 0.5 + 0.5 * twinkle;
        // fade with depth
        const depthFactor = 1 - Math.abs(p.userData.depth) / 30;
        p.material.opacity = baseOpacity * depthFactor;
        // pulse size
        const pulse = 0.8 + 0.3 * Math.cos(time * p.userData.twinkleSpeed + p.userData.twinklePhase);
        const depthScale = 1 + (p.userData.depth / -30) * 1.5; // nearer particles larger
        p.scale.setScalar(p.userData.baseSize * pulse * depthScale);
      });
      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
